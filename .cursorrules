# Cursor Rules – Universal (Hardline / Non-Negotiable)

## 1) Documentation & Markdown – ABSOLUTE RULES (NO EXCEPTIONS)
- ONLY ONE markdown file in the ENTIRE repository: README.md
- README.md MUST be in the repository root
- ZERO other .md files are allowed anywhere (docs/, src/, results/, notes/, etc.)
- If ANY other markdown file exists:
  - Extract any relevant/current information into README.md
  - DELETE the markdown file immediately
  - Do NOT archive, do NOT rename, do NOT move, do NOT keep duplicates
- NEVER create additional markdown files for any reason
- If a tool/workflow tries to generate markdown (e.g., reports, docs, templates), disable it or replace with non-markdown output

### README.md is a scratchpad (not a wiki, not a manual)
README.md must stay lean and operational. It must contain ONLY:
- Current status / what we’re doing right now
- Current decisions (structure/approach) that matter today
- Minimal usage instructions needed to run the project
- Pointers to the key entry points (commands, scripts, modules)
- “Next actions” and “known issues” (short, actionable)

README.md must NOT become:
- A historical log
- A dumping ground
- Long-form documentation
- A design essay
If it grows, compress it: keep only what is currently useful.

## 2) Character Set Policy – ABSOLUTE ASCII ONLY (DESTROY VIOLATIONS)
- The entire repository must be ASCII-only:
  - code
  - comments
  - strings
  - README.md
  - config files
  - filenames
  - generated artifacts (if kept in repo)
- FORBIDDEN EVERYWHERE:
  - emojis
  - Greek letters (α, β, λ, θ, …)
  - accents/diacritics (é, ñ, ü, …)
  - smart quotes (“, ”, ‘, ’)
  - en/em dashes (–, —)
  - any non-keyboard Unicode symbols
- If any forbidden characters appear anywhere:
  - Replace with ASCII equivalents immediately
  - If the file is non-essential or auto-generated, delete it instead of “fixing” it
- Prefer ASCII spellings: alpha, beta, lambda, theta; use "-" not "–"

## 3) Code Quality – PRECISE, LEAN, AND MAINTAINABLE
- Code must be precise and correct over being clever
- Prefer simple, explicit logic
- Avoid “magic” behavior and hidden side effects
- Every module should have a clear purpose and stable interface
- Remove dead code immediately (not later)
- Remove unused imports immediately
- Duplicate functionality is a bug: merge into one well-designed implementation

### Comments (minimal, but useful)
- Comments must be minimal and high-signal
- Comment ONLY when it adds information not obvious from the code:
  - invariants
  - tricky edge cases
  - why a decision exists (short)
- No decorative comments
- No long “tutorial” comment blocks
- If code needs extensive explanation, the code structure/naming is wrong—refactor instead

## 4) File & Module Consolidation – CONTINUOUS REFACTORING
- Consolidate Python/code files aggressively:
  - merge duplicates
  - remove redundant modules
  - prefer fewer, stronger files
- Do not keep legacy code “just in case”
- Old experiments, abandoned scripts, and superseded implementations must be removed or isolated so they cannot interfere with the current workflow
- One behavior = one canonical implementation

## 5) Directory Structure – INDUSTRY-STANDARD, PRODUCTION WORKFLOW
You must maintain a professional structure. Default to these industry conventions:

### Math Mode Structure (for mathematical/computational projects)
When working in "math mode", the directory structure is:
- Base directory (root) contains:
  - .cursorrules
  - README.md
  - requirements.txt
  - .git/ (version control)
  - .gitignore
  - venv/ or equivalent (gitignored virtual environment)
- Project directories:
  - scripts/          (executable scripts and entry points)
    - figures/        (figure outputs from scripts)
    - example/        (example-specific outputs from scripts)
  - src/              (source code modules)
  - results/          (computed results and outputs)
    - figures/        (figure outputs)
    - example/        (example-specific results)
  - data/             (input datasets, must be downloaded/external)

This structure separates code (src/), execution (scripts/), outputs (results/), and data (data/).

### Preferred top-level layout (pick the appropriate standard and stick to it)
- src/ layout (recommended for Python packages):
  - src/<package_name>/...
  - tests/...
  - README.md (root)
  - pyproject.toml (or equivalent)
- OR a minimal app layout (if not a distributable package):
  - <package_or_app_name>/...
  - tests/...
  - scripts/ (thin wrappers only)
  - README.md (root)

### Allowed top-level directories (only if needed)
- src/           (package code)
- <pkg>/         (if not using src layout)
- tests/         (unit/integration tests)
- scripts/       (entry scripts; keep thin)
- configs/       (explicit config files)
- data/          (ONLY if small; otherwise external)
- notebooks/     (ONLY if unavoidable; keep minimal; no unicode; no markdown exports)
- results/       (ONLY if necessary; prefer gitignored artifacts)

### Strong guidance (non-negotiable style)
- Prefer depth over breadth: avoid dumping many unrelated files into root
- Root must stay clean: only core config + README + a small number of obvious directories
- Do not create "misc/", "tmp/", "old/", "archive/" directories
- Generated artifacts should be gitignored unless explicitly required
- Large datasets and bulky outputs should not live in the repo by default

## 6) File Creation Rules – DEFAULT TO MODIFY, ASK WHEN JUDGMENT IS INVOLVED
- Prefer modifying existing files over creating new ones
- Only create a new file when it is structurally justified
- If there are multiple valid architectural choices, STOP and ask questions first
- If the task is obvious and mechanical, do it immediately

## 7) Operational Discipline – NO BACKGROUND COMMANDS
- NEVER run commands in the background
- Always run in foreground so output is visible
- React to errors immediately; do not “assume it worked”

## 8) Periodic Maintenance – PROFESSIONAL STANDARDS ENFORCEMENT
After any significant change, do a quick maintenance pass:
- Directory structure sanity check (lean, modern, non-redundant)
- Consolidate code files (merge duplicates, remove redundancy)
- Delete or gitignore artifacts that don’t belong
- Ensure README.md is still lean and current
- Ensure ASCII-only compliance everywhere

## 9) Version Control and Environment Setup – MANDATORY
- ALWAYS use Git version control for every project (remote hosting optional, and only if explicitly requested)
- ALWAYS initialize and maintain a virtual environment for Python projects
- ALWAYS maintain a requirements.txt file that tracks all dependencies
- Treat the Git commit graph (DAG) as a first-class project artifact
- Commit after EVERY major change (architecture, refactors, restructuring, logic changes)
- Do NOT batch unrelated changes into a single commit
- Use an aggressive .gitignore by default:
  - ignore generated artifacts, caches, logs, outputs, temp files, environments
  - only track files that are essential and reproducible
- When unsure whether a file should be tracked, default to ignoring it
- Git exists to preserve structure, reasoning, and reversibility over time

### Virtual Environment Requirements
- Create a virtual environment at project start (python -m venv venv or equivalent)
- Activate the virtual environment before running any Python commands
- Update requirements.txt whenever dependencies are added or changed
- Use pip freeze > requirements.txt to capture exact versions when needed
- The virtual environment directory (venv/, env/, .venv/) must be gitignored
- Document activation commands in README.md if non-standard

## 10) NO PLACEHOLDERS, NO FALLBACKS, NO LIES – ABSOLUTE RULE
- DO NOT have placeholders, DO NOT have fallbacks, DO NOT have dummy data
- IF it fails, it fails hard with clear error messages
- IF you need something, ASK the user explicitly
- DO NOT add lies such as fallbacks and placeholders into the code EVER
- IF ever you see one, remove it without hesitation
- Code must either work correctly or fail explicitly - no silent degradation, no fake data, no "TODO" implementations
- Every function must either accomplish its stated purpose or raise an exception explaining why it cannot

## 11) PRINT STATEMENTS – FUNCTIONAL AND MINIMAL
- Print statements must be functional and minimal
- NO decorative prints (e.g., lines of "=" characters, borders, banners)
- NO unnecessary status messages or verbose progress updates
- Print only essential information needed for understanding output
- EDA and analysis scripts should report data, not decorate output
- If output needs structure, use simple spacing, not decorative characters

## 12) RANDOM SEED POLICY – ABSOLUTE RULE
- ALL random seeds must be set to 14 (NEVER 42 or any other value)
- This applies to:
  - numpy.random.RandomState
  - random.seed()
  - torch.manual_seed()
  - Any other random number generator initialization
- When creating random projections, embeddings, or any stochastic components, use seed=14
- Document seed usage in code comments when relevant
- This ensures reproducibility across all experiments